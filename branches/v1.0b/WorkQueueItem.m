//
//  WorkQueueItem.m
//  TiVo Butler
//
//  Created by Eric Baur on 2/7/08.
//  Copyright 2008 Eric Shore Baur. All rights reserved.
//

#import "WorkQueueItem.h"

@implementation WorkQueueItem


+ (void)initialize
{
	ENTRY;
	NSUserDefaultsController *defaults = [NSUserDefaultsController sharedUserDefaultsController];

	NSDictionary *tempDefaults;
	tempDefaults = [self workflowDefaults];
	
	[defaults setInitialValues:tempDefaults];
}

- (void)awakeFromInsert
{
	ENTRY;
	self.addedDate = [NSDate date];
	
	NSUserDefaultsController *defaults = [NSUserDefaultsController sharedUserDefaultsController];
	self.shouldKeepInput = [[defaults valueForKey:@"values"] valueForKey:@"keepIntermediateFiles"];
}

- (BOOL)canRemove
{
	if ( [self.active boolValue] ) {
		return NO;
	} else {
		return YES;
	}
}

#pragma mark -
#pragma mark Accessor methods

@dynamic actionType;
@dynamic active;
@dynamic addedDate;
@dynamic completedDate;
@dynamic shouldKeepInput;
@dynamic message;
@dynamic sourceType;
@dynamic startedDate;
@dynamic savedPath;

@dynamic program;
@dynamic readFile;
@dynamic writeFile;

- (void)setActionType:(NSNumber *)value 
{
	ENTRY;
	if ( [self.actionType intValue] ) {
		WARNING( @"attempt to re-set actionType (blocking)" );
		return;
	}
	int action = [value intValue];
	if ( action > WQAction_MIN && action <= WQAction_MAX ) {
		[self willChangeValueForKey:@"actionType"];
		[self setPrimitiveActionType:value];
		[self didChangeValueForKey:@"actionType"];
		
		if ( self.program ) {
			[self setupWriteFile];
		}
	} else {
		WARNING( @"attempt to set actionType to invalid value: %@", [value description] );
	}
}

- (BOOL)validateActionType:(id *)valueRef error:(NSError **)outError 
{
	ENTRY;
	int type = [*valueRef intValue];
	if ( type < WQAction_MIN ) {
		NSDictionary *userInfoDict = [NSDictionary dictionaryWithObject:@"Action type too small." forKey:NSLocalizedDescriptionKey];
		*outError = [NSError errorWithDomain:NSCocoaErrorDomain code:-1 userInfo:userInfoDict];
		WARNING( [*outError localizedDescription] );
		return NO;
	}
	if ( type > WQAction_MAX ) {
		NSDictionary *userInfoDict = [NSDictionary dictionaryWithObject:@"Action type too large." forKey:NSLocalizedDescriptionKey];
		*outError = [NSError errorWithDomain:NSCocoaErrorDomain code:-1 userInfo:userInfoDict];
		WARNING( [*outError localizedDescription] );
		return NO;
	}
    return YES;
}


- (NSNumber *)active
{
	if ( nil==self.completedDate && nil!=self.startedDate )
		return [NSNumber numberWithBool:YES];
	else
		return [NSNumber numberWithBool:NO];
}

- (NSString *)name
{
	if ( nil != self.program) {
		return self.program.title;
	} else {
		return @"";
	}
}

- (void)setProgram:(TiVoProgram *)value 
{
	if ( self.program ) {
		WARNING( @"attempt to re-set program value (blocking)" );
		return;
	}
    [self willChangeValueForKey:@"program"];
    [self setPrimitiveProgram:value];
    [self didChangeValueForKey:@"program"];
	
	if ( [self.actionType intValue] ) {
		[self setupWriteFile];
	}
}

- (void)setSourceType:(NSNumber *)value 
{
	if ( [self.sourceType intValue] ) {
		WARNING( @"attempt to re-set sourceType (blocking)" );
		return;
	}
    [self willChangeValueForKey:@"sourceType"];
    [self setPrimitiveSourceType:value];
    [self didChangeValueForKey:@"sourceType"];
}

#pragma mark -
#pragma mark Transient accessors

- (NSString *)sourceName
{
	int type = [self.sourceType intValue];
	switch (type) {
		case WQAutoGeneratedSourceType:	return WQAutoGeneratedSourceString;	break;
		case WQUserInitSourceType:		return WQUserInitSourceString;		break;
		case WQScheduledSourceType:		return WQScheduledSourceString;		break;
		default:						return nil;
	}
}

#pragma mark -
#pragma mark Action methods

- (void)setupWriteFile
{
	self.writeFile =
		[NSEntityDescription
			insertNewObjectForEntityForName:TiVoWorkQueueFileEntityName
			inManagedObjectContext:self.managedObjectContext
		];
	[self setValue:self forKeyPath:@"writeFile.writerItem"];
}


@end
